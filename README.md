# Tutorial: lms_using_mern

This project is a **Learning Management System (LMS)** that allows users to *register as students or instructors*, enroll in courses, and learn online. Instructors can *create and manage their course content*, while students can track their progress. It features a robust **authentication system** to secure user accounts and a *role-based access control* mechanism to differentiate user permissions, ensuring a personalized and secure learning environment.


## Visual Overview

```mermaid
flowchart TD
    A0["Authentication System
"]
    A1["Mongoose Data Models
"]
    A2["Express API Endpoints (Routes)
"]
    A3["React Components
"]
    A4["Frontend Global Authentication State (AuthContext)
"]
    A5["API Data Fetching Hook (useApi)
"]
    A6["Role-Based Access Control (RBAC)
"]
    A7["Course Curriculum Management (Instructor)
"]
    A0 -- "Stores User Data" --> A1
    A0 -- "Exposes Auth Routes" --> A2
    A0 -- "Updates State" --> A4
    A0 -- "Determines User Role" --> A6
    A2 -- "Interacts With" --> A1
    A7 -- "Manages Course Data" --> A1
    A3 -- "Makes Requests To" --> A2
    A5 -- "Calls Endpoints" --> A2
    A6 -- "Protects Routes" --> A2
    A4 -- "Provides Auth Data" --> A3
    A5 -- "Fetches Data For" --> A3
    A6 -- "Conditionally Renders" --> A3
    A7 -- "Implements UI" --> A3
    A4 -- "Supplies Auth Token" --> A5
    A7 -- "Defines Curriculum Routes" --> A2
```

## Chapters

1. [Mongoose Data Models
](01_mongoose_data_models_.md)
2. [Express API Endpoints (Routes)
](02_express_api_endpoints__routes__.md)
3. [Authentication System
](03_authentication_system_.md)
4. [Role-Based Access Control (RBAC)
](04_role_based_access_control__rbac__.md)
5. [Frontend Global Authentication State (AuthContext)
](05_frontend_global_authentication_state__authcontext__.md)
6. [API Data Fetching Hook (`useApi`)
](06_api_data_fetching_hook___useapi___.md)
7. [React Components
](07_react_components_.md)
8. [Course Curriculum Management (Instructor)
](08_course_curriculum_management__instructor__.md)

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub>
# Chapter 1: Mongoose Data Models

Welcome to the exciting journey of building our Learning Management System (LMS) using the MERN stack! In this first chapter, we're going to tackle a super important concept: **Mongoose Data Models**.

### Why Do We Need Data Models?

Imagine you're building a house. You wouldn't just start throwing bricks around, right? You'd need a blueprint â€“ a detailed plan that shows where the walls go, how many rooms there are, and what materials to use.

In our LMS, we'll be dealing with lots of information: users (students, instructors), courses, lessons, enrollments, and so on. If we just stored this information haphazardly, our application would quickly become a messy, confusing place.

**This is the problem Mongoose Data Models solve!** They are like those blueprints for our data. They define:
*   **What kind of information** we're storing (e.g., a user's name, email, password).
*   **What format** that information should be in (e.g., name is text, age is a number).
*   **Any special rules** (e.g., every user *must* have an email, and no two users can have the same email).
*   **How different pieces of information relate** to each other (e.g., a lesson belongs to a module, and a module belongs to a course).

Let's consider a simple use case: **Adding a new student to our LMS**. How do we ensure that when we create a new student, we always get their name and email, and that their email is unique (meaning no other student can use the same email)? Mongoose Data Models give us the tools to enforce these rules right from the start!

### What is Mongoose?

Before diving into models, let's briefly introduce **Mongoose**. Our LMS stores its data in a **MongoDB** database. MongoDB is a "NoSQL" database that stores data in flexible, JSON-like documents.

Mongoose is a powerful tool (an "Object Data Modeling" library) that acts as a bridge between our Node.js (backend) application and our MongoDB database. It makes working with MongoDB much easier by providing structure and validation to our data.

### The Building Blocks: Schema and Model

Mongoose Data Models are built on two main concepts:

1.  **Schema**: Think of a Schema as the **blueprint** itself. It's where we define the structure of our data. We declare what fields a document will have, their data types (like `String`, `Number`, `Boolean`, `Date`), and any validation rules (like `required` or `unique`).

2.  **Model**: A Model is a **constructor function** that uses the Schema. It's the actual tool we use to interact with the database. We use models to create, read, update, and delete documents based on the rules defined in their Schema.

**Analogy Time!**
*   **Schema**: A cookie cutter that defines the shape and design of a cookie.
*   **Model**: The action of using that cookie cutter to make and manage actual cookies.
*   **Document**: An actual cookie you've made, conforming to the cookie cutter's shape.
*   **Collection**: The whole batch of cookies you've baked and stored.

### Defining Your First Data Model: The User Blueprint

Let's look at how we define a `User` model, which is essential for any LMS. This model will define how all user information is structured in our database.

Our project defines the `User` model in the file: `backend/src/models/User.js`.

```javascript
import mongoose from 'mongoose';

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Please provide a name'], // Rule: name must be a string and is mandatory
  },
  email: {
    type: String,
    required: [true, 'Please provide an email'],
    unique: true, // Rule: email must be unique across all users
    // ... more email validation rules
  },
  password: {
    type: String,
    required: [true, 'Please provide a password'],
    minlength: 6, // Rule: password must be at least 6 characters long
    select: false, // Rule: don't include password in query results by default
  },
  role: {
    type: String,
    enum: ['student', 'instructor', 'admin'], // Rule: role must be one of these values
    default: 'student', // Rule: if no role is given, it defaults to 'student'
  },
  // ... other fields like avatar
}, { timestamps: true }); // Automatically adds 'createdAt' and 'updatedAt' fields

// Special logic to hash password before saving (explained later)
// userSchema.pre('save', async function (next) { /* ... */ });

const User = mongoose.model('User', userSchema); // Creates the User Model from the schema
export default User;
```

**Let's break down `userSchema` step by step:**

*   `import mongoose from 'mongoose';`: We first import the Mongoose library.
*   `const userSchema = new mongoose.Schema({ ... });`: This is where we create our `userSchema`. Inside the curly braces `{}`, we define each field our user document will have:
    *   `name`:
        *   `type: String`: This field will store text.
        *   `required: [true, 'Please provide a name']`: This is a validation rule. It means a `name` *must* be provided when creating a new user. If not, Mongoose will give an error with the message "Please provide a name".
    *   `email`:
        *   `type: String`, `required: [true, 'Please provide an email']`: Similar to `name`, it's a required string.
        *   `unique: true`: This is crucial! It ensures that no two users can have the same email address in our database.
    *   `password`:
        *   `type: String`, `required: [true, 'Please provide a password']`, `minlength: 6`: A required string, at least 6 characters long.
        *   `select: false`: This is a security feature. By default, when you query for a user, the password field won't be sent back unless you explicitly ask for it.
    *   `role`:
        *   `type: String`: Stores text.
        *   `enum: ['student', 'instructor', 'admin']`: This limits the possible values for `role` to only "student", "instructor", or "admin". No other role can be saved.
        *   `default: 'student'`: If a role isn't specified when creating a user, it will automatically be set to "student".
*   `{ timestamps: true }`: This is an *option* for the schema. When `timestamps` is `true`, Mongoose automatically adds `createdAt` and `updatedAt` fields to our documents, showing when they were first created and last modified. Super handy!
*   `const User = mongoose.model('User', userSchema);`: Finally, we take our `userSchema` blueprint and create an actual `User` Model. We'll use this `User` model to interact with our user data in the database.
*   `export default User;`: We export the `User` model so other parts of our backend application can use it.

### Using Our User Model

Now that we have our `User` model, how do we use it to add a new student? Let's see a simplified example of creating a user:

```javascript
// This code would be in another backend file, e.g., a controller
import User from '../models/User.js'; // Import our User model

async function registerNewUser(name, email, password) {
  try {
    const newUser = await User.create({
      name: name,
      email: email,
      password: password, // Mongoose will hash this before saving!
      // role will default to 'student'
    });
    console.log('Successfully created user:', newUser.name, newUser.email);
    return newUser;
  } catch (error) {
    console.error('Error creating user:', error.message);
    // This will catch errors like 'email already exists' or 'missing name'
  }
}

// Example usage:
// Input: registerNewUser("Alice Smith", "alice@example.com", "mySecurePass");
// Expected Output (if successful):
// Successfully created user: Alice Smith alice@example.com
// A new document will be stored in MongoDB for Alice.

// Input: registerNewUser("Bob Johnson", "alice@example.com", "anotherPass");
// Expected Output (if failed due to unique email constraint):
// Error creating user: E11000 duplicate key error collection: ... email_1 dup key: { email: "alice@example.com" }
```
In this example, `User.create()` is a method provided by Mongoose Models. When we call it, Mongoose uses the `userSchema` to validate our data before trying to save it to MongoDB. This ensures our data always follows the rules we've set.

### Linking Data Together: Relationships

Our LMS isn't just about users; it's about courses, modules, and lessons too. How do we show that a `Module` belongs to a `Course`, or that an `Enrollment` connects a `Student` to a `Course`? Mongoose Data Models allow us to define these relationships.

Let's look at `backend/src/models/Course.js` and `backend/src/models/Module.js`:

```javascript
// From: backend/src/models/Course.js (simplified)
import mongoose from "mongoose";

const courseSchema = new mongoose.Schema(
  {
    title: { type: String, required: true },
    description: { type: String, required: true },
    curriculum: [{ // A course has a curriculum, which is a list of modules
      type: mongoose.Schema.Types.ObjectId, // This field will store an ID
      ref: 'Module', // This ID refers to a document in the 'Module' collection
    }],
    createdBy: { // Who created this course?
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User', // This ID refers to a document in the 'User' collection
      required: true,
    },
    // ... other course fields
  },
  { timestamps: true }
);

const Course = mongoose.model("Course", courseSchema);
export default Course;
```

```javascript
// From: backend/src/models/Module.js (simplified)
import mongoose from 'mongoose';

const moduleSchema = new mongoose.Schema({
  title: { type: String, required: true },
  lessons: [{ // A module has a list of lessons
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Lesson', // This ID refers to a document in the 'Lesson' collection
  }],
  course: { // Which course does this module belong to?
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Course', // This ID refers to a document in the 'Course' collection
    required: true,
  },
}, { timestamps: true });

const Module = mongoose.model('Module', moduleSchema);
export default Module;
```
Notice `type: mongoose.Schema.Types.ObjectId` and `ref: 'AnotherModel'`. This is how we create links! Instead of embedding all the module details directly into the course, we just store the `_id` (a unique identifier) of the related `Module` document. This keeps our data organized and avoids duplication. Mongoose then allows us to easily "populate" these references, meaning we can fetch the actual `Module` document details when we need them.

You'll see similar relationship definitions in `backend/src/models/Lesson.js` and `backend/src/models/Enrollment.js` which connect lessons to modules, and enrollments to courses and students.

### Under the Hood: How Mongoose Models Work

When you use a Mongoose Model, a lot happens behind the scenes to ensure your data is structured and saved correctly.

Let's trace what happens when our backend code tries to create a new user:

1.  **Request to Create**: Your backend application (e.g., handling a user signup request) calls a Mongoose Model function like `User.create()`, providing the user's data (name, email, password).
2.  **Schema Validation**: Mongoose takes this data and immediately compares it against the `userSchema`.
    *   Is `name` a string? Is it present?
    *   Is `email` a string? Is it present? Does it match the regex pattern? Is it *unique* in the database?
    *   Is `password` a string? Is it present? Is it at least 6 characters long?
    *   If any rule is broken, Mongoose stops here and sends back an error message to your application.
3.  **Pre-save Hooks (Middleware)**: If validation passes, Mongoose checks if there are any special actions to perform *before* saving. For our `User` model, we have a `userSchema.pre('save', ...)` hook that **hashes the password** using `bcryptjs`. This is a critical security step â€“ we never store plain text passwords!
4.  **Database Interaction**: After validation and any pre-save actions, Mongoose formats the data into a MongoDB-friendly document. It then sends this document to your MongoDB database with an instruction to save it.
5.  **Database Confirmation**: MongoDB saves the document (e.g., in the `users` collection) and sends a confirmation back to Mongoose.
6.  **Response to Application**: Mongoose then takes the saved document (which now includes `_id`, `createdAt`, `updatedAt`, and the hashed password) and returns it to your backend application.

Here's a simple sequence diagram to visualize this process:

```mermaid
sequenceDiagram
    participant BackendApp as Your Backend App
    participant Mongoose as Mongoose Library
    participant MongoDB as MongoDB Database

    BackendApp->>Mongoose: 1. `User.create({ name: "Bob", email: "bob@example.com", password: "123" })`
    Mongoose->>Mongoose: 2. Validate data against `userSchema` rules
    Note over Mongoose: Checks required fields, unique email, etc.
    Mongoose->>Mongoose: 3. Run `pre('save')` hooks (e.g., hash password)
    Mongoose->>MongoDB: 4. Insert new document into `users` collection
    MongoDB-->>Mongoose: 5. Confirmation (document saved)
    Mongoose-->>BackendApp: 6. Return created User object
```

This structured approach, enforced by Mongoose Data Models, is what makes our backend robust and reliable.

### Conclusion

Congratulations! You've just taken your first step into understanding the backbone of our `lms_using_mern` project's data storage: **Mongoose Data Models**. You learned that:

*   They are like blueprints for our data, defining structure, types, and validation rules.
*   `Schema` defines the blueprint, and `Model` is the tool we use to interact with the database.
*   They enforce data consistency and help us create relationships between different pieces of information (like a `Course` having many `Modules`).
*   They provide powerful features like automatic timestamps and pre-save hooks for tasks like password hashing.

These models are the foundation for how all our application's information is organized and stored. Now that we understand how our data is structured, the next logical step is to learn how our frontend application can *ask for* and *send* this structured data to our backend. This is where [Express API Endpoints (Routes)](02_express_api_endpoints__routes__.md) come in, which we'll explore in the next chapter!

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/models/Course.js), [[2]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/models/Enrollment.js), [[3]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/models/Lesson.js), [[4]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/models/Module.js), [[5]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/models/User.js)</sup></sub>
# Chapter 2: Express API Endpoints (Routes)

Welcome back, aspiring MERN stack developer! In our last chapter, [Mongoose Data Models](01_mongoose_data_models_.md), we learned how to create blueprints for our data, ensuring our users, courses, and lessons are stored neatly and consistently in our MongoDB database. We have our data structure defined, like knowing what ingredients go into a recipe.

Now, imagine you've set up a fantastic kitchen (your backend with data models), but how do customers (your frontend) order food? They don't just walk into the kitchen and start grabbing ingredients! They need a menu and a way to place an order.

**This is the problem Express API Endpoints (Routes) solve!**

### Why Do We Need API Endpoints?

API Endpoints are like the **menu** and **order counter** for your backend services. They define:
*   **What services your backend offers**: "Get all courses," "Register a new user," "Update a lesson."
*   **How to ask for these services**: Specific URLs and "methods" (like asking for information, or sending new information).

**Let's use a concrete example**: How does our LMS frontend application show a list of all available courses to a student?

The frontend can't directly peek into the database. It needs a way to *ask* the backend, "Hey, can you give me all the courses?" The backend, in turn, needs a specific address where it expects such requests and a way to process them. This "address" and "way to process" is exactly what an API endpoint is.

### What is an API Endpoint (Route)?

At its core, an API endpoint (often just called a "route" in Express.js) is a combination of two things:

1.  **A URL Path**: This is the specific address, like `/api/courses` or `/api/auth/login`. Think of it as the specific dish name on the menu.
2.  **An HTTP Method (Verb)**: This tells the backend *what kind of action* you want to perform with that URL. Is it just to *get* information, *send* new information, *update* existing information, or *delete* something? Think of it as "ordering," "changing," or "cancelling" an item.

Together, a URL path and an HTTP method form a unique endpoint. For example, `GET /api/courses` is different from `POST /api/courses`.

### Common HTTP Methods (The "Verbs")

Here are the most common HTTP methods we'll use in our LMS, explained simply:

| HTTP Method | What it Means (Analogy)              | Purpose in LMS                                   |
| :---------- | :----------------------------------- | :----------------------------------------------- |
| **GET**     | **G**et information (Look at the menu) | Fetch data (e.g., get all courses, get user profile) |
| **POST**    | **P**ost new information (Place an order) | Create new data (e.g., register a new user, create a course) |
| **PUT**     | **P**ut updated information (Change an order) | Update existing data (e.g., update course details, change password) |
| **DELETE**  | **D**elete information (Cancel an order) | Remove data (e.g., delete a lesson)             |

### How Express.js Helps (The "Router")

Our backend uses **Express.js**, a popular Node.js framework, to handle these API endpoints. Express makes it super easy to define routes and connect them to functions that do the actual work.

To keep our code organized (which is super important in larger applications!), Express allows us to create separate "mini-applications" called **Routers**. Each router can handle routes for a specific part of our application, like `auth.routes.js` for authentication, `courseRoutes.js` for courses, and so on.

### Solving Our Use Case: Getting All Courses

Let's revisit our use case: "How does the frontend show a list of all available courses?"

1.  The frontend needs to make a `GET` request.
2.  The URL path should be something like `/api/courses`.

So, the full endpoint will be `GET /api/courses`.

Here's how we set this up in our Express backend:

First, in our main `backend/src/server.js` file, we tell Express to use a specific router for anything starting with `/api/courses`:

```javascript
// backend/src/server.js (simplified)
import express from 'express';
import courseRoutes from "./routes/courseRoutes.js"; // Import our course-specific routes

const app = express();

// ... other setup like connecting to MongoDB ...

// API Routes
// When a request comes in for /api/courses, send it to courseRoutes
app.use("/api/courses", courseRoutes);

// ... server start code ...
```
**Explanation**: This `app.use("/api/courses", courseRoutes);` line is like telling the server: "Any request that starts with `/api/courses` (e.g., `/api/courses`, `/api/courses/123`, `/api/courses/my-creations`) should be handled by the logic defined in `courseRoutes.js`."

Next, in `backend/src/routes/courseRoutes.js`, we define the actual endpoint for getting all courses:

```javascript
// backend/src/routes/courseRoutes.js (simplified)
import express from 'express';
// We'll import a function called 'getAllCourses' from a controller
import { getAllCourses } from '../controllers/course.controller.js';

const router = express.Router(); // Create a new Express Router

// This defines the GET /api/courses endpoint
// The '/' here means '/api/courses' because of how it's used in server.js
router.get('/', getAllCourses); // When a GET request comes to '/', call getAllCourses

// ... other course-related routes like POST / (create course) ...

export default router;
```
**Explanation**:
*   `const router = express.Router();` creates a mini-Express app just for course routes.
*   `router.get('/', getAllCourses);` tells this router: "If you receive a `GET` request for the root path (`/`), execute the `getAllCourses` function." Because our `server.js` already prefixed this router with `/api/courses`, this effectively becomes `GET /api/courses`.

Finally, what does `getAllCourses` (which is in `backend/src/controllers/course.controller.js`) actually do? It's the worker function that contains the business logic. For getting all courses, it would typically use our [Mongoose Data Models](01_mongoose_data_models_.md) to fetch data from the database.

```javascript
// backend/src/controllers/course.controller.js (simplified)
import Course from '../models/Course.js'; // Import our Course Mongoose Model

// This function will be called when GET /api/courses is requested
export const getAllCourses = async (req, res) => {
  try {
    const courses = await Course.find({}); // Use Mongoose to find all courses
    res.status(200).json(courses); // Send the found courses back as JSON
  } catch (error) {
    res.status(500).json({ message: error.message }); // Handle errors
  }
};
```
**Explanation**:
*   `Course.find({});` uses our `Course` model (defined in [Mongoose Data Models](01_mongoose_data_models_.md)) to query the MongoDB database and find all course documents.
*   `res.status(200).json(courses);` sends a successful (200 OK) response back to the frontend, containing the list of courses in JSON format.

**Example Input/Output**:
*   **Input (Frontend request)**: A web browser or a React app makes a `GET` request to `http://localhost:5000/api/courses`.
*   **Expected Output (Backend response)**:
    ```json
    [
      {
        "_id": "65b9d3e7a0f4b3c2d1e0f1a2",
        "title": "Introduction to JavaScript",
        "description": "Learn the basics of JavaScript programming.",
        "createdBy": "65b9d3e7a0f4b3c2d1e0f1a3",
        "createdAt": "2024-01-30T10:00:00.000Z",
        "updatedAt": "2024-01-30T10:00:00.000Z",
        "__v": 0
      },
      {
        "_id": "65b9d3e7a0f4b3c2d1e0f1b4",
        "title": "React for Beginners",
        "description": "Build interactive user interfaces with React.",
        "createdBy": "65b9d3e7a0f4b3c2d1e0f1a3",
        "createdAt": "2024-01-31T11:00:00.000Z",
        "updatedAt": "2024-01-31T11:00:00.000Z",
        "__v": 0
      }
    ]
    ```
    The frontend receives this JSON data and can then display the course titles and descriptions to the user.

### Under the Hood: How an API Request Flows

Let's trace a request for `GET /api/courses` from the frontend to the database and back, step-by-step:

1.  **Frontend makes Request**: Your React application (or a browser) sends a `GET` request to `http://localhost:5000/api/courses`.
2.  **Express Server Receives**: The main `server.js` file, which is listening on port 5000, receives this incoming request.
3.  **Route Matching (Main Server)**: Express looks at its configured routes. It sees `app.use("/api/courses", courseRoutes);` and knows that any request starting with `/api/courses` should be passed to the `courseRoutes` router.
4.  **Route Matching (Specific Router)**: The `courseRoutes.js` router now takes over. It looks at the remaining part of the URL (which is just `/` since `/api/courses` was matched) and the `GET` method. It finds `router.get('/', getAllCourses);` and executes the `getAllCourses` function.
5.  **Controller Logic**: The `getAllCourses` function runs. It uses our `Course` [Mongoose Data Model](01_mongoose_data_models_.md) to query the MongoDB database.
6.  **Database Interaction**: Mongoose translates the query (`Course.find({})`) into a command for MongoDB, which then fetches all course documents.
7.  **Database Response**: MongoDB sends the found documents back to Mongoose.
8.  **Controller Sends Response**: The `getAllCourses` function takes the data from Mongoose, formats it as JSON, and sends it back to the client using `res.status(200).json(courses);`.
9.  **Express Sends Response**: Express packages this JSON data and sends it over the network back to the frontend.
10. **Frontend Receives**: The frontend application receives the JSON data and can now render the list of courses.

Here's a simple sequence diagram to visualize this flow:

```mermaid
sequenceDiagram
    participant Frontend
    participant Server as Express Server
    participant CourseRoutes as `courseRoutes.js`
    participant CourseController as `course.controller.js`
    participant MongoDB

    Frontend->>Server: 1. GET /api/courses
    Server->>CourseRoutes: 2. Match `/api/courses` path
    CourseRoutes->>CourseController: 3. Call `getAllCourses` function for `GET /`
    CourseController->>MongoDB: 4. `Course.find({})` (via Mongoose)
    MongoDB-->>CourseController: 5. Returns course data
    CourseController-->>CourseRoutes: 6. Returns `res.json(courses)`
    CourseRoutes-->>Server: 7. Handles response
    Server-->>Frontend: 8. Sends JSON response (list of courses)
```

You'll see similar patterns for other routes in our project:
*   `backend/src/routes/auth.routes.js` handles `POST /api/auth/register` and `POST /api/auth/login`.
*   `backend/src/routes/user.routes.js` handles `PUT /api/users/update-profile` for logged-in users.
*   `backend/src/routes/enrollmentRoutes.js` handles `GET /api/enrollments/me` to get a user's enrollments.

Each of these files defines a set of related routes and directs them to specific controller functions, keeping our backend tidy and maintainable!

### Conclusion

You've now grasped the fundamental concept of **Express API Endpoints (Routes)**! You've learned that:

*   Endpoints are the "menu items" of your backend, defining specific URLs and actions (HTTP methods) that the frontend can use.
*   HTTP methods like GET, POST, PUT, and DELETE specify the type of operation.
*   Express.js uses `app.use` to delegate sections of routes to specialized `Router` files (like `courseRoutes.js`).
*   Each route then calls a "controller" function that contains the actual logic (often interacting with our [Mongoose Data Models](01_mongoose_data_models_.md)).

These routes are the gateways that allow our frontend application to communicate with our powerful backend. But what if we want to restrict certain "menu items" to only logged-in users, or only instructors? That's where **Authentication** comes in, and it's what we'll dive into in our next chapter: [Authentication System](03_authentication_system_.md)!

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/routes/adminRoutes.js), [[2]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/routes/auth.routes.js), [[3]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/routes/courseRoutes.js), [[4]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/routes/enrollmentRoutes.js), [[5]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/routes/lessonRoutes.js), [[6]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/routes/user.routes.js), [[7]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/server.js)</sup></sub>
# Chapter 3: Authentication System

Welcome back! In our previous chapter, [Express API Endpoints (Routes)](02_express_api_endpoints__routes__.md), we learned how to set up the "menu" and "order counter" for our backend, allowing the frontend to ask for or send data. We can now get a list of courses or create a new one.

But what if we only want *registered students* to enroll in a course, or only *instructors* to create one? What if someone tries to access sensitive information without proving who they are?

**This is the problem the Authentication System solves!**

### Why Do We Need an Authentication System?

Imagine our LMS is a secure building.
*   **Registration** is like applying for and getting an ID card for the first time.
*   **Logging in** is like showing your ID card at the entrance to prove you are who you say you are.
*   **Being logged in** means you're inside the building, and the security knows you're legitimate.

Without an authentication system, anyone could pretend to be anyone, create courses, enroll in courses, or access private user data. It would be total chaos!

Our **Authentication System** is the security checkpoint and ID verification process for our entire LMS application. It handles:
*   **User Registration (Signing Up)**: Creating a new account and getting your first ID.
*   **Logging In (Proving Identity)**: Presenting your ID to gain access.
*   **Maintaining User Session**: Ensuring the application remembers you're logged in as you move around, without you having to show your ID at every single door.

**Let's use a concrete example**: How does a user sign up for our LMS, and then how do they log in to access their personalized dashboard?

### Key Concepts of Authentication

Our authentication system relies on a few core ideas:

1.  **User Credentials**: This is the email and password you use to log in. It's your secret key to prove your identity.
2.  **JSON Web Tokens (JWTs)**: Pronounced "jot," this is our digital ID badge. Once you log in, the server gives you a JWT. Your frontend application then keeps this JWT and sends it with almost every request to the backend. The backend can quickly verify this token to know who you are and if you're allowed to access the requested resource. It's like a temporary, verifiable pass.
3.  **Password Hashing**: We **never** store passwords in plain text in our database. Instead, we convert them into a scrambled, irreversible string (a "hash"). When you log in, we hash your entered password and compare it to the stored hash. If they match, you're in! This protects user passwords even if our database is compromised.
4.  **Protected Routes**: These are [API Endpoints](02_express_api_endpoints__routes__.md) that require a valid JWT to access. For example, `GET /api/users/me` (get my profile) or `POST /api/courses` (create a course) would be protected.

### Solving Our Use Case: Registering and Logging In a User

Let's walk through the process of how a user registers and then logs into our LMS.

#### Step 1: User Registers on the Frontend

A new user visits our LMS website and goes to the registration page. They fill out a form with their name, email, password, and chosen role (student/instructor).

When they click "Create Account," our frontend code (in `frontend/src/components/Register.jsx`) sends this data to our backend.

```javascript
// frontend/src/components/Register.jsx (Simplified)
import React, { useState, useContext } from "react";
import { AuthContext } from "../context/AuthContext"; // Where we manage login state
import { API_BASE_URL } from "../api/client";

function Register() {
  const { login } = useContext(AuthContext); // Access login function
  const [formData, setFormData] = useState({ /* ... name, email, password, role */ });
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    try {
      const res = await fetch(`${API_BASE_URL}/auth/register`, { // ðŸ‘ˆ Send POST request
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData), // ðŸ‘ˆ User data goes here
      });

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message);
      }

      const data = await res.json(); // Get user info and JWT from backend
      login(data.user, data.token); // ðŸ‘ˆ Store them in our AuthContext
      // ... navigate to dashboard ...
    } catch (err) {
      // ... handle error ...
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* ... input fields for name, email, password, role ... */}
      <button type="submit">Create Account</button>
    </form>
  );
}
export default Register;
```
**Explanation**:
*   The `handleSubmit` function makes a `POST` request to `/api/auth/register`.
*   It sends the user's `formData` (name, email, password, role) as JSON in the request body.
*   If registration is successful, the backend sends back `data.user` (the new user's details without password) and `data.token` (the JWT).
*   `login(data.user, data.token)` then stores this information in our `AuthContext` (more on this in [Frontend Global Authentication State (AuthContext)](05_frontend_global_authentication_state__authcontext__.md)) and in `localStorage`, effectively logging the user in immediately.

#### Step 2: Backend Handles Registration

The `POST /api/auth/register` request arrives at our Express backend. The `auth.routes.js` file directs it to the `registerUser` function in `auth.controller.js`.

```javascript
// backend/src/routes/auth.routes.js (Simplified)
import express from 'express';
import { registerUser, loginUser } from '../controllers/auth.controller.js';

const router = express.Router();

router.post('/register', registerUser); // ðŸ‘ˆ This maps to our registerUser function
router.post('/login', loginUser);

export default router;
```

Now, let's see what happens inside `registerUser`:

```javascript
// backend/src/controllers/auth.controller.js (Simplified)
import User from '../models/User.js'; // Our Mongoose User Model
import generateToken from '../utils/generateToken.js'; // Helper to create JWTs

export const registerUser = async (req, res) => {
  const { name, email, password, role } = req.body; // Get data from frontend

  try {
    const userExists = await User.findOne({ email }); // Check if email is already taken
    if (userExists) {
      return res.status(400).json({ message: 'User already exists' });
    }

    // Create a new user in the database using our User model
    // The password will be HASHED AUTOMATICALLY before saving!
    const user = await User.create({ name, email, password, role });

    const token = generateToken(user._id); // Create a JWT for the new user

    // Prepare user data to send back (without password)
    const userWithoutPassword = await User.findById(user._id).select('-password');

    res.status(201).json({ user: userWithoutPassword, token }); // Send back user info & JWT
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};
```
**Explanation**:
1.  It gets the `name`, `email`, `password`, `role` from the request.
2.  It checks if a user with that email already exists using `User.findOne()`. If so, it sends an error.
3.  `User.create({ name, email, password, role })` creates a new user. **Crucially**, before this user is saved, our `User` model has a special "pre-save hook" that automatically **hashes the password**.
    ```javascript
    // backend/src/models/User.js (Simplified)
    import mongoose from 'mongoose';
    import bcrypt from 'bcryptjs'; // For hashing passwords

    const userSchema = new mongoose.Schema({ /* ... name, email, password, role ... */ });

    // ðŸ‘ˆ This is the pre-save hook!
    userSchema.pre('save', async function (next) {
      if (!this.isModified('password')) return next(); // Only hash if password was changed
      const salt = await bcrypt.genSalt(10); // Generate a random "salt"
      this.password = await bcrypt.hash(this.password, salt); // Hash the password
      next();
    });

    const User = mongoose.model('User', userSchema);
    export default User;
    ```
    This `userSchema.pre('save')` is a Mongoose "middleware" that runs *before* a `User` document is saved to the database. It uses `bcryptjs` to scramble the plain text password into a secure hash.
4.  After the user is saved, `generateToken(user._id)` creates a JSON Web Token.
    ```javascript
    // backend/src/utils/generateToken.js
    import jwt from "jsonwebtoken";

    const generateToken = (user) => {
      return jwt.sign(
        { id: user._id, role: user.role }, // The 'payload' - info stored in the token
        process.env.JWT_SECRET, // ðŸ‘ˆ A secret key only the server knows
        { expiresIn: "30d" } // Token expires in 30 days
      );
    };

    export default generateToken;
    ```
    This function takes the user's ID (and role, etc.) and combines it with a secret key (`process.env.JWT_SECRET`) to create a unique, encoded string. This string is the JWT.
5.  Finally, the `registerUser` function sends back the new user's details (without the sensitive password) and the generated JWT to the frontend.

**Example Input/Output (Register)**:
*   **Input (Frontend sends to `POST /api/auth/register`)**:
    ```json
    {
      "name": "Jane Doe",
      "email": "jane@example.com",
      "password": "mysecretpassword123",
      "role": "student"
    }
    ```
*   **Expected Output (Backend sends back)**:
    ```json
    {
      "user": {
        "_id": "65b9d3e7a0f4b3c2d1e0f1a2",
        "name": "Jane Doe",
        "email": "jane@example.com",
        "role": "student",
        "createdAt": "2024-01-30T10:00:00.000Z",
        "updatedAt": "2024-01-30T10:00:00.000Z"
      },
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY1YjlkM2U3YTBmNGIzYzJkMWUwZjFhMiIsInJvbGUiOiJzdHVkZW50IiwiaWF0IjoxNzEwMDAwMDAwLCJleHAiOjE3MTI2MDM2MDB9.some_long_jwt_string_here"
    }
    ```
    The `token` is then stored by the frontend.

#### Step 3: User Logs In on the Frontend

Now that Jane has an account, she can log in. She goes to the login page and enters her email and password.

```javascript
// frontend/src/components/Login.jsx (Simplified)
import React, { useState, useContext } from "react";
import { AuthContext } from "../context/AuthContext";
import { API_BASE_URL } from "../api/client";

function Login() {
  const { login } = useContext(AuthContext);
  const [formData, setFormData] = useState({ /* ... email, password */ });
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    try {
      const res = await fetch(`${API_BASE_URL}/auth/login`, { // ðŸ‘ˆ Send POST request
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData), // ðŸ‘ˆ User's email and password
      });

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message);
      }

      const data = await res.json(); // Get user info and new JWT
      login(data.user, data.token); // ðŸ‘ˆ Store them
      // ... navigate to dashboard ...
    } catch (err) {
      // ... handle error ...
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* ... input fields for email, password ... */}
      <button type="submit">Sign In</button>
    </form>
  );
}
export default Login;
```
**Explanation**: Similar to registration, the frontend sends the `email` and `password` to `POST /api/auth/login`. If successful, the backend returns the user data and a new JWT, which `AuthContext.login` stores.

#### Step 4: Backend Handles Login

The `POST /api/auth/login` request is routed to the `loginUser` function in `auth.controller.js`.

```javascript
// backend/src/controllers/auth.controller.js (Simplified)
import User from '../models/User.js';
import bcrypt from 'bcryptjs'; // For comparing hashed passwords
import generateToken from '../utils/generateToken.js';

export const loginUser = async (req, res) => {
  const { email, password } = req.body;

  try {
    // Find user and EXPLICITLY include password for comparison (normally it's excluded)
    const user = await User.findOne({ email }).select('+password');

    if (!user) {
      return res.status(401).json({ message: 'Invalid email or password' });
    }

    // Compare the plain text password from login with the hashed password in DB
    const isMatch = await bcrypt.compare(password, user.password);

    if (!isMatch) {
      return res.status(401).json({ message: 'Invalid email or password' });
    }

    const token = generateToken(user._id); // Generate a new JWT for the session
    const userWithoutPassword = await User.findById(user._id).select('-password');

    res.status(200).json({ user: userWithoutPassword, token });
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message });
  }
};
```
**Explanation**:
1.  It receives the `email` and `password`.
2.  It finds the user by `email` using `User.findOne()`. `select('+password')` is important here because our `User` model is set to *not* include the password by default (`select: false`). For login, we *need* the password to compare.
3.  `bcrypt.compare(password, user.password)` compares the plain text password from the request with the hashed password stored in the database. This is a secure comparison.
4.  If the passwords match, `generateToken(user._id)` creates a new JWT for the user's current session.
5.  The user's details (without password) and the new JWT are sent back to the frontend.

**Example Input/Output (Login)**:
*   **Input (Frontend sends to `POST /api/auth/login`)**:
    ```json
    {
      "email": "jane@example.com",
      "password": "mysecretpassword123"
    }
    ```
*   **Expected Output (Backend sends back)**:
    ```json
    {
      "user": {
        "_id": "65b9d3e7a0f4b3c2d1e0f1a2",
        "name": "Jane Doe",
        "email": "jane@example.com",
        "role": "student",
        "createdAt": "2024-01-30T10:00:00.000Z",
        "updatedAt": "2024-01-30T10:00:00.000Z"
      },
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY1YjlkM2U3YTBmNGIzYzJkMWUwZjFhMiIsInJvbGUiOiJzdHVkZW50IiwiaWF0IjoxNzEwMDAxMDAwLCJleHAiOjE3MTI2MDQ2MDB9.another_long_jwt_string_here"
    }
    ```

### Under the Hood: JWT Verification (Protecting Routes)

Once a user is logged in and has a JWT, how does the system know they are authorized for *other* actions, like enrolling in a course?

1.  **Frontend Sends JWT**: For any request to a protected route (e.g., `POST /api/enrollments`), the frontend includes the JWT in the `Authorization` header of the request, usually like `Authorization: Bearer <YOUR_JWT_HERE>`.
    ```javascript
    // Example: A frontend request to a protected route
    // (This would be handled by useApi hook or similar, covered in Chapter 6)
    const token = localStorage.getItem('token'); // Get stored token
    await fetch(`${API_BASE_URL}/enrollments`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}` // ðŸ‘ˆ Sending the JWT
      },
      body: JSON.stringify({ courseId: 'someCourseId' }),
    });
    ```
2.  **Backend `isAuthenticated` Middleware**: Before the actual route handler (like `createEnrollment`) runs, a special Express "middleware" function, `isAuthenticated`, intercepts the request.
    ```javascript
    // backend/src/middlewares/auth.middleware.js (Simplified)
    import jwt from 'jsonwebtoken';
    import asyncHandler from 'express-async-handler'; // For error handling
    import User from '../models/User.js';

    const isAuthenticated = asyncHandler(async (req, res, next) => {
      let token;
      // 1. Check if the token is in the Authorization header
      if (req.headers.authorization?.startsWith('Bearer')) {
        try {
          token = req.headers.authorization.split(' ')[1]; // Extract token part
          const decoded = jwt.verify(token, process.env.JWT_SECRET); // 2. Verify token
          req.user = await User.findById(decoded.id).select('-password'); // 3. Find user by ID from token
          next(); // 4. If all good, proceed to the actual route handler
        } catch (error) {
          res.status(401);
          throw new Error('Not authorized, token failed'); // Invalid token
        }
      }
      if (!token) {
        res.status(401);
        throw new Error('Not authorized, no token'); // No token provided
      }
    });

    export { isAuthenticated };
    ```
3.  **Route Protection**: In `enrollmentRoutes.js`, you'd see `isAuthenticated` used to protect the `POST /` route:
    ```javascript
    // backend/src/routes/enrollmentRoutes.js (Simplified)
    import express from 'express';
    import { createEnrollment } from '../controllers/enrollment.controller.js';
    import { isAuthenticated } from '../middlewares/auth.middleware.js'; // ðŸ‘ˆ Our security guard

    const router = express.Router();

    router.post('/', isAuthenticated, createEnrollment); // ðŸ‘ˆ Protected route

    export default router;
    ```
    Here, `isAuthenticated` acts like a security guard. It runs *before* `createEnrollment`. If the token is valid, `isAuthenticated` calls `next()`, allowing `createEnrollment` to run. If the token is missing or invalid, it stops the request and sends an error.

Here's a sequence diagram illustrating the entire flow for a protected request:

```mermaid
sequenceDiagram
    participant Frontend
    participant ExpressAuth as Express Auth Middleware (`isAuthenticated`)
    participant ExpressController as Express Controller (e.g., `createEnrollment`)
    participant MongooseUser as Mongoose User Model
    participant JWTUtility as JWT Utility (`jwt.verify`)

    Frontend->>ExpressAuth: 1. Request to protected API (e.g., POST /api/enrollments) with JWT in "Authorization: Bearer <token>"
    ExpressAuth->>JWTUtility: 2. Extract and verify JWT with secret key
    JWTUtility-->>ExpressAuth: 3. Decoded payload (user ID, role)
    ExpressAuth->>MongooseUser: 4. Find user details using ID from token (exclude password)
    MongooseUser-->>ExpressAuth: 5. User object
    ExpressAuth->>ExpressController: 6. Attach `req.user` and call `next()` to proceed
    ExpressController->>ExpressController: 7. Perform action (e.g., create enrollment for `req.user`)
    ExpressController-->>Frontend: 8. Send API response
```
This multi-step process ensures that every request to a protected resource is authenticated, meaning we know *who* is making the request, before processing it further.

### Conclusion

You've now uncovered the core of our `lms_using_mern` project's security: the **Authentication System**. You learned:

*   It's like the security system for our application, handling who can get in and what they can do.
*   **Registration** creates a user, and **Login** verifies their identity using email and password.
*   **JSON Web Tokens (JWTs)** are the digital ID badges issued upon successful login, used by the frontend to prove identity on subsequent requests.
*   **Password Hashing** (`bcryptjs` in Mongoose pre-save hooks) keeps user passwords secure.
*   An `isAuthenticated` middleware function on the backend verifies JWTs to protect routes, ensuring only legitimate users access certain functionalities.

Knowing *who* the user is, thanks to authentication, is just the first step. The next critical question is: *What can this specific user (e.g., a student vs. an instructor) actually *do*? This brings us to **Role-Based Access Control (RBAC)**, which we'll explore in the next chapter!

[Chapter 4: Role-Based Access Control (RBAC)](04_role_based_access_control__rbac__.md)

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/controllers/auth.controller.js), [[2]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/middlewares/auth.middleware.js), [[3]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/models/User.js), [[4]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/routes/auth.routes.js), [[5]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/backend/src/utils/generateToken.js), [[6]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/frontend/src/components/Login.jsx), [[7]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/frontend/src/components/Register.jsx), [[8]](https://github.com/rockstarrk04/lms_using_mern/blob/c62988c79f29cd2003e1518bdc401842a9d28b2c/frontend/src/context/AuthContext.jsx)</sup></sub>
